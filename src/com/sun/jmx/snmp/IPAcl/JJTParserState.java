/**
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * <p>
 * Generated By:JJTree: Do not edit this line. JJTParserState.java
 */
/** Generated By:JJTree: Do not edit this line. JJTParserState.java */
package com.sun.jmx.snmp.IPAcl;

class JJTParserState{
    private java.util.Stack<Node> nodes;
    private java.util.Stack<Integer> marks;
    private int sp;               // number of nodes on stack
    private int mk;               // current mark
    private boolean node_created;

    JJTParserState(){
        nodes=new java.util.Stack<>();
        marks=new java.util.Stack<>();
        sp=0;
        mk=0;
    }

    boolean nodeCreated(){
        return node_created;
    }

    void reset(){
        nodes.removeAllElements();
        marks.removeAllElements();
        sp=0;
        mk=0;
    }

    Node rootNode(){
        return nodes.elementAt(0);
    }

    Node peekNode(){
        return nodes.peek();
    }

    void clearNodeScope(Node n){
        while(sp>mk){
            popNode();
        }
        mk=marks.pop().intValue();
    }

    Node popNode(){
        if(--sp<mk){
            mk=marks.pop().intValue();
        }
        return nodes.pop();
    }

    void openNodeScope(Node n){
        marks.push(new Integer(mk));
        mk=sp;
        n.jjtOpen();
    }

    void closeNodeScope(Node n,int num){
        mk=marks.pop().intValue();
        while(num-->0){
            Node c=popNode();
            c.jjtSetParent(n);
            n.jjtAddChild(c,num);
        }
        n.jjtClose();
        pushNode(n);
        node_created=true;
    }

    void pushNode(Node n){
        nodes.push(n);
        ++sp;
    }

    void closeNodeScope(Node n,boolean condition){
        if(condition){
            int a=nodeArity();
            mk=marks.pop().intValue();
            while(a-->0){
                Node c=popNode();
                c.jjtSetParent(n);
                n.jjtAddChild(c,a);
            }
            n.jjtClose();
            pushNode(n);
            node_created=true;
        }else{
            mk=marks.pop().intValue();
            node_created=false;
        }
    }

    int nodeArity(){
        return sp-mk;
    }
}
