/**
 * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 * <p>
 * Copyright 2001-2004 The Apache Software Foundation.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * <p>
 * $Id: ToTextStream.java,v 1.2.4.1 2005/09/21 10:35:34 pvedula Exp $
 */
/**
 * Copyright 2001-2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * $Id: ToTextStream.java,v 1.2.4.1 2005/09/21 10:35:34 pvedula Exp $
 */
package com.sun.org.apache.xml.internal.serializer;

import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
import com.sun.org.apache.xml.internal.serializer.utils.Utils;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

import java.io.IOException;

public final class ToTextStream extends ToStream{
    public ToTextStream(){
        super();
    }

    public void endDocument() throws SAXException{
        flushPending();
        flushWriter();
        if(m_tracer!=null)
            super.fireEndDoc();
    }

    public void processingInstruction(String target,String data)
            throws SAXException{
        // flush anything pending first
        flushPending();
        if(m_tracer!=null)
            super.fireEscapingEvent(target,data);
    }

    public void cdata(char ch[],int start,int length)
            throws SAXException{
        try{
            writeNormalizedChars(ch,start,length,m_lineSepUse);
            if(m_tracer!=null)
                super.fireCDATAEvent(ch,start,length);
        }catch(IOException ioe){
            throw new SAXException(ioe);
        }
    }

    public void charactersRaw(char ch[],int start,int length)
            throws SAXException{
        try{
            writeNormalizedChars(ch,start,length,m_lineSepUse);
        }catch(IOException ioe){
            throw new SAXException(ioe);
        }
    }

    public void characters(char ch[],int start,int length)
            throws SAXException{
        flushPending();
        try{
            if(inTemporaryOutputState()){
                /** leave characters un-processed as we are
                 * creating temporary output, the output generated by
                 * this serializer will be input to a final serializer
                 * later on and it will do the processing in final
                 * output state (not temporary output state).
                 *
                 * A "temporary" ToTextStream serializer is used to
                 * evaluate attribute value templates (for example),
                 * and the result of evaluating such a thing
                 * is fed into a final serializer later on.
                 */
                m_writer.write(ch,start,length);
            }else{
                // In final output state we do process the characters!
                writeNormalizedChars(ch,start,length,m_lineSepUse);
            }
            if(m_tracer!=null)
                super.fireCharEvent(ch,start,length);
        }catch(IOException ioe){
            throw new SAXException(ioe);
        }
    }

    public void characters(String characters)
            throws SAXException{
        final int length=characters.length();
        if(length>m_charsBuff.length){
            m_charsBuff=new char[length*2+1];
        }
        characters.getChars(0,length,m_charsBuff,0);
        characters(m_charsBuff,0,length);
    }

    public void startElement(
            String namespaceURI,String localName,String name,Attributes atts)
            throws SAXException{
        // time to fire off startElement event
        if(m_tracer!=null){
            super.fireStartElem(name);
            this.firePseudoAttributes();
        }
        return;
    }

    public void startElement(
            String elementNamespaceURI,
            String elementLocalName,
            String elementName)
            throws SAXException{
        if(m_needToCallStartDocument)
            startDocumentInternal();
        // time to fire off startlement event.
        if(m_tracer!=null){
            super.fireStartElem(elementName);
            this.firePseudoAttributes();
        }
        return;
    }

    public void endElement(String namespaceURI,String localName,String name)
            throws SAXException{
        if(m_tracer!=null)
            super.fireEndElem(name);
    }

    public void endElement(String elemName) throws SAXException{
        if(m_tracer!=null)
            super.fireEndElem(elemName);
    }

    public void startPrefixMapping(String prefix,String uri)
            throws SAXException{
        // no namespace support for HTML
    }

    public boolean startPrefixMapping(
            String prefix,
            String uri,
            boolean shouldFlush)
            throws SAXException{
        // no namespace support for HTML
        return false;
    }

    public void comment(char ch[],int start,int length)
            throws SAXException{
        flushPending();
        if(m_tracer!=null)
            super.fireCommentEvent(ch,start,length);
    }

    public void endCDATA() throws SAXException{
        // do nothing
    }

    public void ignorableWhitespace(char ch[],int start,int length)
            throws SAXException{
        try{
            writeNormalizedChars(ch,start,length,m_lineSepUse);
        }catch(IOException ioe){
            throw new SAXException(ioe);
        }
    }

    public void flushPending() throws SAXException{
        if(m_needToCallStartDocument){
            startDocumentInternal();
            m_needToCallStartDocument=false;
        }
    }

    void writeNormalizedChars(
            final char ch[],
            final int start,
            final int length,
            final boolean useLineSep)
            throws IOException, SAXException{
        final String encoding=getEncoding();
        final java.io.Writer writer=m_writer;
        final int end=start+length;
        /** copy a few "constants" before the loop for performance */
        final char S_LINEFEED=CharInfo.S_LINEFEED;
        // This for() loop always increments i by one at the end
        // of the loop.  Additional increments of i adjust for when
        // two input characters (a high/low UTF16 surrogate pair)
        // are processed.
        for(int i=start;i<end;i++){
            final char c=ch[i];
            if(S_LINEFEED==c&&useLineSep){
                writer.write(m_lineSep,0,m_lineSepLen);
                // one input char processed
            }else if(m_encodingInfo.isInEncoding(c)){
                writer.write(c);
                // one input char processed
            }else if(Encodings.isHighUTF16Surrogate(c)){
                final int codePoint=writeUTF16Surrogate(c,ch,i,end);
                if(codePoint!=0){
                    // I think we can just emit the message,
                    // not crash and burn.
                    final String integralValue=Integer.toString(codePoint);
                    final String msg=Utils.messages.createMessage(
                            MsgKey.ER_ILLEGAL_CHARACTER,
                            new Object[]{integralValue,encoding});
                    //Older behavior was to throw the message,
                    //but newer gentler behavior is to write a message to System.err
                    //throw new SAXException(msg);
                    System.err.println(msg);
                }
                i++; // two input chars processed
            }else{
                // Don't know what to do with this char, it is
                // not in the encoding and not a high char in
                // a surrogate pair, so write out as an entity ref
                if(encoding!=null){
                    /** The output encoding is known,
                     * so somthing is wrong.
                     */
                    // not in the encoding, so write out a character reference
                    writer.write('&');
                    writer.write('#');
                    writer.write(Integer.toString(c));
                    writer.write(';');
                    // I think we can just emit the message,
                    // not crash and burn.
                    final String integralValue=Integer.toString(c);
                    final String msg=Utils.messages.createMessage(
                            MsgKey.ER_ILLEGAL_CHARACTER,
                            new Object[]{integralValue,encoding});
                    //Older behavior was to throw the message,
                    //but newer gentler behavior is to write a message to System.err
                    //throw new SAXException(msg);
                    System.err.println(msg);
                }else{
                    /** The output encoding is not known,
                     * so just write it out as-is.
                     */
                    writer.write(c);
                }
                // one input char was processed
            }
        }
    }

    public void comment(String data) throws SAXException{
        final int length=data.length();
        if(length>m_charsBuff.length){
            m_charsBuff=new char[length*2+1];
        }
        data.getChars(0,length,m_charsBuff,0);
        comment(m_charsBuff,0,length);
    }

    public void addAttribute(
            String uri,
            String localName,
            String rawName,
            String type,
            String value,
            boolean XSLAttribute){
        // do nothing, just forget all about the attribute
    }

    public void addAttribute(String name,String value){
        // do nothing, forget about the attribute
    }

    public void namespaceAfterStartElement(
            final String prefix,
            final String uri)
            throws SAXException{
        // no namespace support for HTML
    }

    public void entityReference(String name) throws SAXException{
        if(m_tracer!=null)
            super.fireEntityReference(name);
    }

    protected void startDocumentInternal() throws SAXException{
        super.startDocumentInternal();
        m_needToCallStartDocument=false;
        // No action for the moment.
    }

    public void addUniqueAttribute(String qName,String value,int flags)
            throws SAXException{
        // do nothing, forget about the attribute
    }
}
