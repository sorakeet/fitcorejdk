/**
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
package javax.swing;

import javax.accessibility.Accessible;
import javax.accessibility.AccessibleContext;
import javax.accessibility.AccessibleRole;
import javax.swing.border.Border;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.plaf.ViewportUI;
import java.awt.*;
import java.awt.event.*;
import java.awt.peer.ComponentPeer;
import java.beans.Transient;
import java.io.Serializable;

public class JViewport extends JComponent implements Accessible{
    public static final int BLIT_SCROLL_MODE=1;
    public static final int BACKINGSTORE_SCROLL_MODE=2;
    public static final int SIMPLE_SCROLL_MODE=0;
    static final Object EnableWindowBlit="EnableWindowBlit";
    private static final String uiClassID="ViewportUI";
    protected boolean isViewSizeSet=false;
    protected Point lastPaintPosition=null;
    @Deprecated
    protected boolean backingStore=false;
    transient protected Image backingStoreImage=null;
    protected boolean scrollUnderway=false;
    private ComponentListener viewListener=null;
    private transient ChangeEvent changeEvent=null;
    private int scrollMode=BLIT_SCROLL_MODE;
    //
    // Window blitting:
    //
    // As mentioned in the javadoc when using windowBlit a paint event
    // will be generated by the system if copyArea copies a non-visible
    // portion of the view (in other words, it copies garbage). We are
    // not guaranteed to receive the paint event before other mouse events,
    // so we can not be sure we haven't already copied garbage a bunch of
    // times to different parts of the view. For that reason when a blit
    // happens and the Component is obscured (the check for obscurity
    // is not supported on all platforms and is checked via ComponentPeer
    // methods) the ivar repaintAll is set to true. When paint is received
    // if repaintAll is true (we previously did a blit) it is set to
    // false, and if the clip region is smaller than the viewport
    // waitingForRepaint is set to true and a timer is started. When
    // the timer fires if waitingForRepaint is true, repaint is invoked.
    // In the mean time, if the view is asked to scroll and waitingForRepaint
    // is true, a blit will not happen, instead the non-backing store case
    // of scrolling will happen, which will reset waitingForRepaint.
    // waitingForRepaint is set to false in paint when the clip rect is
    // bigger (or equal) to the size of the viewport.
    // A Timer is used instead of just a repaint as it appeared to offer
    // better performance.
    private transient boolean repaintAll;
    private transient boolean waitingForRepaint;
    private transient Timer repaintTimer;
    private transient boolean inBlitPaint;
    private boolean hasHadValidView;
    private boolean viewChanged;

    public JViewport(){
        super();
        setLayout(createLayoutManager());
        setOpaque(true);
        updateUI();
        setInheritsPopupMenu(true);
    }

    public void updateUI(){
        setUI((ViewportUI)UIManager.getUI(this));
    }

    public String getUIClassID(){
        return uiClassID;
    }

    public void paint(Graphics g){
        int width=getWidth();
        int height=getHeight();
        if((width<=0)||(height<=0)){
            return;
        }
        if(inBlitPaint){
            // We invoked paint as part of copyArea cleanup, let it through.
            super.paint(g);
            return;
        }
        if(repaintAll){
            repaintAll=false;
            Rectangle clipB=g.getClipBounds();
            if(clipB.width<getWidth()||
                    clipB.height<getHeight()){
                waitingForRepaint=true;
                if(repaintTimer==null){
                    repaintTimer=createRepaintTimer();
                }
                repaintTimer.stop();
                repaintTimer.start();
                // We really don't need to paint, a future repaint will
                // take care of it, but if we don't we get an ugly flicker.
            }else{
                if(repaintTimer!=null){
                    repaintTimer.stop();
                }
                waitingForRepaint=false;
            }
        }else if(waitingForRepaint){
            // Need a complete repaint before resetting waitingForRepaint
            Rectangle clipB=g.getClipBounds();
            if(clipB.width>=getWidth()&&
                    clipB.height>=getHeight()){
                waitingForRepaint=false;
                repaintTimer.stop();
            }
        }
        if(!backingStore||isBlitting()||getView()==null){
            super.paint(g);
            lastPaintPosition=getViewLocation();
            return;
        }
        // If the view is smaller than the viewport and we are not opaque
        // (that is, we won't paint our background), we should set the
        // clip. Otherwise, as the bounds of the view vary, we will
        // blit garbage into the exposed areas.
        Rectangle viewBounds=getView().getBounds();
        if(!isOpaque()){
            g.clipRect(0,0,viewBounds.width,viewBounds.height);
        }
        if(backingStoreImage==null){
            // Backing store is enabled but this is the first call to paint.
            // Create the backing store, paint it and then copy to g.
            // The backing store image will be created with the size of
            // the viewport. We must make sure the clip region is the
            // same size, otherwise when scrolling the backing image
            // the region outside of the clipped region will not be painted,
            // and result in empty areas.
            backingStoreImage=createImage(width,height);
            Rectangle clip=g.getClipBounds();
            if(clip.width!=width||clip.height!=height){
                if(!isOpaque()){
                    g.setClip(0,0,Math.min(viewBounds.width,width),
                            Math.min(viewBounds.height,height));
                }else{
                    g.setClip(0,0,width,height);
                }
                paintViaBackingStore(g,clip);
            }else{
                paintViaBackingStore(g);
            }
        }else{
            if(!scrollUnderway||lastPaintPosition.equals(getViewLocation())){
                // No scrolling happened: repaint required area via backing store.
                paintViaBackingStore(g);
            }else{
                // The image was scrolled. Manipulate the backing store and flush it to g.
                Point blitFrom=new Point();
                Point blitTo=new Point();
                Dimension blitSize=new Dimension();
                Rectangle blitPaint=new Rectangle();
                Point newLocation=getViewLocation();
                int dx=newLocation.x-lastPaintPosition.x;
                int dy=newLocation.y-lastPaintPosition.y;
                boolean canBlit=computeBlit(dx,dy,blitFrom,blitTo,blitSize,blitPaint);
                if(!canBlit){
                    // The image was either moved diagonally or
                    // moved by more than the image size: paint normally.
                    paintViaBackingStore(g);
                }else{
                    int bdx=blitTo.x-blitFrom.x;
                    int bdy=blitTo.y-blitFrom.y;
                    // Move the relevant part of the backing store.
                    Rectangle clip=g.getClipBounds();
                    // We don't want to inherit the clip region when copying
                    // bits, if it is inherited it will result in not moving
                    // all of the image resulting in garbage appearing on
                    // the screen.
                    g.setClip(0,0,width,height);
                    Graphics bsg=getBackingStoreGraphics(g);
                    try{
                        bsg.copyArea(blitFrom.x,blitFrom.y,blitSize.width,blitSize.height,bdx,bdy);
                        g.setClip(clip.x,clip.y,clip.width,clip.height);
                        // Paint the rest of the view; the part that has just been exposed.
                        Rectangle r=viewBounds.intersection(blitPaint);
                        bsg.setClip(r);
                        super.paint(bsg);
                        // Copy whole of the backing store to g.
                        g.drawImage(backingStoreImage,0,0,this);
                    }finally{
                        bsg.dispose();
                    }
                }
            }
        }
        lastPaintPosition=getViewLocation();
        scrollUnderway=false;
    }

    public final void setBorder(Border border){
        if(border!=null){
            throw new IllegalArgumentException("JViewport.setBorder() not supported");
        }
    }

    public final Insets getInsets(){
        return new Insets(0,0,0,0);
    }

    public final Insets getInsets(Insets insets){
        insets.left=insets.top=insets.right=insets.bottom=0;
        return insets;
    }

    public void scrollRectToVisible(Rectangle contentRect){
        Component view=getView();
        if(view==null){
            return;
        }else{
            if(!view.isValid()){
                // If the view is not valid, validate. scrollRectToVisible
                // may fail if the view is not valid first, contentRect
                // could be bigger than invalid size.
                validateView();
            }
            int dx, dy;
            dx=positionAdjustment(getWidth(),contentRect.width,contentRect.x);
            dy=positionAdjustment(getHeight(),contentRect.height,contentRect.y);
            if(dx!=0||dy!=0){
                Point viewPosition=getViewPosition();
                Dimension viewSize=view.getSize();
                int startX=viewPosition.x;
                int startY=viewPosition.y;
                Dimension extent=getExtentSize();
                viewPosition.x-=dx;
                viewPosition.y-=dy;
                // Only constrain the location if the view is valid. If the
                // the view isn't valid, it typically indicates the view
                // isn't visible yet and most likely has a bogus size as will
                // we, and therefore we shouldn't constrain the scrolling
                if(view.isValid()){
                    if(getParent().getComponentOrientation().isLeftToRight()){
                        if(viewPosition.x+extent.width>viewSize.width){
                            viewPosition.x=Math.max(0,viewSize.width-extent.width);
                        }else if(viewPosition.x<0){
                            viewPosition.x=0;
                        }
                    }else{
                        if(extent.width>viewSize.width){
                            viewPosition.x=viewSize.width-extent.width;
                        }else{
                            viewPosition.x=Math.max(0,Math.min(viewSize.width-extent.width,viewPosition.x));
                        }
                    }
                    if(viewPosition.y+extent.height>viewSize.height){
                        viewPosition.y=Math.max(0,viewSize.height-
                                extent.height);
                    }else if(viewPosition.y<0){
                        viewPosition.y=0;
                    }
                }
                if(viewPosition.x!=startX||viewPosition.y!=startY){
                    setViewPosition(viewPosition);
                    // NOTE: How JViewport currently works with the
                    // backing store is not foolproof. The sequence of
                    // events when setViewPosition
                    // (scrollRectToVisible) is called is to reset the
                    // views bounds, which causes a repaint on the
                    // visible region and sets an ivar indicating
                    // scrolling (scrollUnderway). When
                    // JViewport.paint is invoked if scrollUnderway is
                    // true, the backing store is blitted.  This fails
                    // if between the time setViewPosition is invoked
                    // and paint is received another repaint is queued
                    // indicating part of the view is invalid. There
                    // is no way for JViewport to notice another
                    // repaint has occurred and it ends up blitting
                    // what is now a dirty region and the repaint is
                    // never delivered.
                    // It just so happens JTable encounters this
                    // behavior by way of scrollRectToVisible, for
                    // this reason scrollUnderway is set to false
                    // here, which effectively disables the backing
                    // store.
                    scrollUnderway=false;
                }
            }
        }
    }

    public void reshape(int x,int y,int w,int h){
        boolean sizeChanged=(getWidth()!=w)||(getHeight()!=h);
        if(sizeChanged){
            backingStoreImage=null;
        }
        super.reshape(x,y,w,h);
        if(sizeChanged||viewChanged){
            viewChanged=false;
            fireStateChanged();
        }
    }

    public void repaint(long tm,int x,int y,int w,int h){
        Container parent=getParent();
        if(parent!=null)
            parent.repaint(tm,x+getX(),y+getY(),w,h);
        else
            super.repaint(tm,x,y,w,h);
    }

    public boolean isOptimizedDrawingEnabled(){
        return false;
    }

    protected boolean isPaintingOrigin(){
        return scrollMode==BACKINGSTORE_SCROLL_MODE;
    }

    protected String paramString(){
        String isViewSizeSetString=(isViewSizeSet?
                "true":"false");
        String lastPaintPositionString=(lastPaintPosition!=null?
                lastPaintPosition.toString():"");
        String scrollUnderwayString=(scrollUnderway?
                "true":"false");
        return super.paramString()+
                ",isViewSizeSet="+isViewSizeSetString+
                ",lastPaintPosition="+lastPaintPositionString+
                ",scrollUnderway="+scrollUnderwayString;
    }

    private void paintViaBackingStore(Graphics g){
        Graphics bsg=getBackingStoreGraphics(g);
        try{
            super.paint(bsg);
            g.drawImage(backingStoreImage,0,0,this);
        }finally{
            bsg.dispose();
        }
    }

    private void paintViaBackingStore(Graphics g,Rectangle oClip){
        Graphics bsg=getBackingStoreGraphics(g);
        try{
            super.paint(bsg);
            g.setClip(oClip);
            g.drawImage(backingStoreImage,0,0,this);
        }finally{
            bsg.dispose();
        }
    }

    private Graphics getBackingStoreGraphics(Graphics g){
        Graphics bsg=backingStoreImage.getGraphics();
        bsg.setColor(g.getColor());
        bsg.setFont(g.getFont());
        bsg.setClip(g.getClipBounds());
        return bsg;
    }

    private Point getViewLocation(){
        Component view=getView();
        if(view!=null){
            return view.getLocation();
        }else{
            return new Point(0,0);
        }
    }

    private boolean isBlitting(){
        Component view=getView();
        return (scrollMode==BLIT_SCROLL_MODE)&&
                (view instanceof JComponent)&&view.isOpaque();
    }

    public Component getView(){
        return (getComponentCount()>0)?getComponent(0):null;
    }

    public void setView(Component view){
        /** Remove the viewport's existing children, if any.
         * Note that removeAll() isn't used here because it
         * doesn't call remove() (which JViewport overrides).
         */
        int n=getComponentCount();
        for(int i=n-1;i>=0;i--){
            remove(getComponent(i));
        }
        isViewSizeSet=false;
        if(view!=null){
            super.addImpl(view,null,-1);
            viewListener=createViewListener();
            view.addComponentListener(viewListener);
        }
        if(hasHadValidView){
            // Only fire a change if a view has been installed.
            fireStateChanged();
        }else if(view!=null){
            hasHadValidView=true;
        }
        viewChanged=true;
        revalidate();
        repaint();
    }

    protected ViewListener createViewListener(){
        return new ViewListener();
    }

    protected void fireStateChanged(){
        Object[] listeners=listenerList.getListenerList();
        for(int i=listeners.length-2;i>=0;i-=2){
            if(listeners[i]==ChangeListener.class){
                if(changeEvent==null){
                    changeEvent=new ChangeEvent(this);
                }
                ((ChangeListener)listeners[i+1]).stateChanged(changeEvent);
            }
        }
    }

    protected boolean computeBlit(
            int dx,
            int dy,
            Point blitFrom,
            Point blitTo,
            Dimension blitSize,
            Rectangle blitPaint){
        int dxAbs=Math.abs(dx);
        int dyAbs=Math.abs(dy);
        Dimension extentSize=getExtentSize();
        if((dx==0)&&(dy!=0)&&(dyAbs<extentSize.height)){
            if(dy<0){
                blitFrom.y=-dy;
                blitTo.y=0;
                blitPaint.y=extentSize.height+dy;
            }else{
                blitFrom.y=0;
                blitTo.y=dy;
                blitPaint.y=0;
            }
            blitPaint.x=blitFrom.x=blitTo.x=0;
            blitSize.width=extentSize.width;
            blitSize.height=extentSize.height-dyAbs;
            blitPaint.width=extentSize.width;
            blitPaint.height=dyAbs;
            return true;
        }else if((dy==0)&&(dx!=0)&&(dxAbs<extentSize.width)){
            if(dx<0){
                blitFrom.x=-dx;
                blitTo.x=0;
                blitPaint.x=extentSize.width+dx;
            }else{
                blitFrom.x=0;
                blitTo.x=dx;
                blitPaint.x=0;
            }
            blitPaint.y=blitFrom.y=blitTo.y=0;
            blitSize.width=extentSize.width-dxAbs;
            blitSize.height=extentSize.height;
            blitPaint.width=dxAbs;
            blitPaint.height=extentSize.height;
            return true;
        }else{
            return false;
        }
    }

    @Transient
    public Dimension getExtentSize(){
        return getSize();
    }

    public void setExtentSize(Dimension newExtent){
        Dimension oldExtent=getExtentSize();
        if(!newExtent.equals(oldExtent)){
            setSize(newExtent);
            fireStateChanged();
        }
    }

    private Timer createRepaintTimer(){
        Timer timer=new Timer(300,new ActionListener(){
            public void actionPerformed(ActionEvent ae){
                // waitingForRepaint will be false if a paint came down
                // with the complete clip rect, in which case we don't
                // have to cause a repaint.
                if(waitingForRepaint){
                    repaint();
                }
            }
        });
        timer.setRepeats(false);
        return timer;
    }

    protected LayoutManager createLayoutManager(){
        return ViewportLayout.SHARED_INSTANCE;
    }

    public ViewportUI getUI(){
        return (ViewportUI)ui;
    }

    public void setUI(ViewportUI ui){
        super.setUI(ui);
    }

    protected void addImpl(Component child,Object constraints,int index){
        setView(child);
    }

    public void remove(Component child){
        child.removeComponentListener(viewListener);
        super.remove(child);
    }

    private void validateView(){
        Component validateRoot=SwingUtilities.getValidateRoot(this,false);
        if(validateRoot==null){
            return;
        }
        // Validate the root.
        validateRoot.validate();
        // And let the RepaintManager it does not have to validate from
        // validateRoot anymore.
        RepaintManager rm=RepaintManager.currentManager(this);
        if(rm!=null){
            rm.removeInvalidComponent((JComponent)validateRoot);
        }
    }

    private int positionAdjustment(int parentWidth,int childWidth,int childAt){
        //   +-----+
        //   | --- |     No Change
        //   +-----+
        if(childAt>=0&&childWidth+childAt<=parentWidth){
            return 0;
        }
        //   +-----+
        //  ---------   No Change
        //   +-----+
        if(childAt<=0&&childWidth+childAt>=parentWidth){
            return 0;
        }
        //   +-----+          +-----+
        //   |   ----    ->   | ----|
        //   +-----+          +-----+
        if(childAt>0&&childWidth<=parentWidth){
            return -childAt+parentWidth-childWidth;
        }
        //   +-----+             +-----+
        //   |  --------  ->     |--------
        //   +-----+             +-----+
        if(childAt>=0&&childWidth>=parentWidth){
            return -childAt;
        }
        //   +-----+          +-----+
        // ----    |     ->   |---- |
        //   +-----+          +-----+
        if(childAt<=0&&childWidth<=parentWidth){
            return -childAt;
        }
        //   +-----+             +-----+
        //-------- |      ->   --------|
        //   +-----+             +-----+
        if(childAt<0&&childWidth>=parentWidth){
            return -childAt+parentWidth-childWidth;
        }
        return 0;
    }

    public int getScrollMode(){
        return scrollMode;
    }

    public void setScrollMode(int mode){
        scrollMode=mode;
        backingStore=mode==BACKINGSTORE_SCROLL_MODE;
    }

    @Deprecated
    public boolean isBackingStoreEnabled(){
        return scrollMode==BACKINGSTORE_SCROLL_MODE;
    }

    @Deprecated
    public void setBackingStoreEnabled(boolean enabled){
        if(enabled){
            setScrollMode(BACKINGSTORE_SCROLL_MODE);
        }else{
            setScrollMode(BLIT_SCROLL_MODE);
        }
    }

    public Dimension getViewSize(){
        Component view=getView();
        if(view==null){
            return new Dimension(0,0);
        }else if(isViewSizeSet){
            return view.getSize();
        }else{
            return view.getPreferredSize();
        }
    }

    public void setViewSize(Dimension newSize){
        Component view=getView();
        if(view!=null){
            Dimension oldSize=view.getSize();
            if(!newSize.equals(oldSize)){
                // scrollUnderway will be true if this is invoked as the
                // result of a validate and setViewPosition was previously
                // invoked.
                scrollUnderway=false;
                view.setSize(newSize);
                isViewSizeSet=true;
                fireStateChanged();
            }
        }
    }

    public Rectangle getViewRect(){
        return new Rectangle(getViewPosition(),getExtentSize());
    }

    public Point getViewPosition(){
        Component view=getView();
        if(view!=null){
            Point p=view.getLocation();
            p.x=-p.x;
            p.y=-p.y;
            return p;
        }else{
            return new Point(0,0);
        }
    }

    public void setViewPosition(Point p){
        Component view=getView();
        if(view==null){
            return;
        }
        int oldX, oldY, x=p.x, y=p.y;
        /** Collect the old x,y values for the views location
         * and do the song and dance to avoid allocating
         * a Rectangle object if we don't have to.
         */
        if(view instanceof JComponent){
            JComponent c=(JComponent)view;
            oldX=c.getX();
            oldY=c.getY();
        }else{
            Rectangle r=view.getBounds();
            oldX=r.x;
            oldY=r.y;
        }
        /** The view scrolls in the opposite direction to mouse
         * movement.
         */
        int newX=-x;
        int newY=-y;
        if((oldX!=newX)||(oldY!=newY)){
            if(!waitingForRepaint&&isBlitting()&&canUseWindowBlitter()){
                RepaintManager rm=RepaintManager.currentManager(this);
                // The cast to JComponent will work, if view is not
                // a JComponent, isBlitting will return false.
                JComponent jview=(JComponent)view;
                Rectangle dirty=rm.getDirtyRegion(jview);
                if(dirty==null||!dirty.contains(jview.getVisibleRect())){
                    rm.beginPaint();
                    try{
                        Graphics g=JComponent.safelyGetGraphics(this);
                        flushViewDirtyRegion(g,dirty);
                        view.setLocation(newX,newY);
                        Rectangle r=new Rectangle(
                                0,0,getWidth(),Math.min(getHeight(),jview.getHeight()));
                        g.setClip(r);
                        // Repaint the complete component if the blit succeeded
                        // and needsRepaintAfterBlit returns true.
                        repaintAll=(windowBlitPaint(g)&&
                                needsRepaintAfterBlit());
                        g.dispose();
                        rm.notifyRepaintPerformed(this,r.x,r.y,r.width,r.height);
                        rm.markCompletelyClean((JComponent)getParent());
                        rm.markCompletelyClean(this);
                        rm.markCompletelyClean(jview);
                    }finally{
                        rm.endPaint();
                    }
                }else{
                    // The visible region is dirty, no point in doing copyArea
                    view.setLocation(newX,newY);
                    repaintAll=false;
                }
            }else{
                scrollUnderway=true;
                // This calls setBounds(), and then repaint().
                view.setLocation(newX,newY);
                repaintAll=false;
            }
            // we must validate the hierarchy to not break the hw/lw mixing
            revalidate();
            fireStateChanged();
        }
    }

    public Dimension toViewCoordinates(Dimension size){
        return new Dimension(size);
    }

    public Point toViewCoordinates(Point p){
        return new Point(p);
    }

    public void addChangeListener(ChangeListener l){
        listenerList.add(ChangeListener.class,l);
    }

    public void removeChangeListener(ChangeListener l){
        listenerList.remove(ChangeListener.class,l);
    }

    public ChangeListener[] getChangeListeners(){
        return listenerList.getListeners(ChangeListener.class);
    }
    //
    // Following is used when doBlit is true.
    //

    protected void firePropertyChange(String propertyName,Object oldValue,
                                      Object newValue){
        super.firePropertyChange(propertyName,oldValue,newValue);
        if(propertyName.equals(EnableWindowBlit)){
            if(newValue!=null){
                setScrollMode(BLIT_SCROLL_MODE);
            }else{
                setScrollMode(SIMPLE_SCROLL_MODE);
            }
        }
    }

    public AccessibleContext getAccessibleContext(){
        if(accessibleContext==null){
            accessibleContext=new AccessibleJViewport();
        }
        return accessibleContext;
    }

    private boolean needsRepaintAfterBlit(){
        // Find the first heavy weight ancestor. isObscured and
        // canDetermineObscurity are only appropriate for heavy weights.
        Component heavyParent=getParent();
        while(heavyParent!=null&&heavyParent.isLightweight()){
            heavyParent=heavyParent.getParent();
        }
        if(heavyParent!=null){
            ComponentPeer peer=heavyParent.getPeer();
            if(peer!=null&&peer.canDetermineObscurity()&&
                    !peer.isObscured()){
                // The peer says we aren't obscured, therefore we can assume
                // that we won't later be messaged to paint a portion that
                // we tried to blit that wasn't valid.
                // It is certainly possible that when we blited we were
                // obscured, and by the time this is invoked we aren't, but the
                // chances of that happening are pretty slim.
                return false;
            }
        }
        return true;
    }

    private void flushViewDirtyRegion(Graphics g,Rectangle dirty){
        JComponent view=(JComponent)getView();
        if(dirty!=null&&dirty.width>0&&dirty.height>0){
            dirty.x+=view.getX();
            dirty.y+=view.getY();
            Rectangle clip=g.getClipBounds();
            if(clip==null){
                // Only happens in 1.2
                g.setClip(0,0,getWidth(),getHeight());
            }
            g.clipRect(dirty.x,dirty.y,dirty.width,dirty.height);
            clip=g.getClipBounds();
            // Only paint the dirty region if it is visible.
            if(clip.width>0&&clip.height>0){
                paintView(g);
            }
        }
    }

    private boolean windowBlitPaint(Graphics g){
        int width=getWidth();
        int height=getHeight();
        if((width==0)||(height==0)){
            return false;
        }
        boolean retValue;
        RepaintManager rm=RepaintManager.currentManager(this);
        JComponent view=(JComponent)getView();
        if(lastPaintPosition==null||
                lastPaintPosition.equals(getViewLocation())){
            paintView(g);
            retValue=false;
        }else{
            // The image was scrolled. Manipulate the backing store and flush
            // it to g.
            Point blitFrom=new Point();
            Point blitTo=new Point();
            Dimension blitSize=new Dimension();
            Rectangle blitPaint=new Rectangle();
            Point newLocation=getViewLocation();
            int dx=newLocation.x-lastPaintPosition.x;
            int dy=newLocation.y-lastPaintPosition.y;
            boolean canBlit=computeBlit(dx,dy,blitFrom,blitTo,blitSize,
                    blitPaint);
            if(!canBlit){
                paintView(g);
                retValue=false;
            }else{
                // Prepare the rest of the view; the part that has just been
                // exposed.
                Rectangle r=view.getBounds().intersection(blitPaint);
                r.x-=view.getX();
                r.y-=view.getY();
                blitDoubleBuffered(view,g,r.x,r.y,r.width,r.height,
                        blitFrom.x,blitFrom.y,blitTo.x,blitTo.y,
                        blitSize.width,blitSize.height);
                retValue=true;
            }
        }
        lastPaintPosition=getViewLocation();
        return retValue;
    }
    //
    // NOTE: the code below uses paintForceDoubleBuffered for historical
    // reasons.  If we're going to allow a blit we've already accounted for
    // everything that paintImmediately and _paintImmediately does, for that
    // reason we call into paintForceDoubleBuffered to diregard whether or
    // not setDoubleBuffered(true) was invoked on the view.
    //

    private void blitDoubleBuffered(JComponent view,Graphics g,
                                    int clipX,int clipY,int clipW,int clipH,
                                    int blitFromX,int blitFromY,int blitToX,int blitToY,
                                    int blitW,int blitH){
        // NOTE:
        //   blitFrom/blitTo are in JViewport coordinates system
        //     not the views coordinate space.
        //   clip* are in the views coordinate space.
        RepaintManager rm=RepaintManager.currentManager(this);
        int bdx=blitToX-blitFromX;
        int bdy=blitToY-blitFromY;
        Composite oldComposite=null;
        // Shift the scrolled region
        if(g instanceof Graphics2D){
            Graphics2D g2d=(Graphics2D)g;
            oldComposite=g2d.getComposite();
            g2d.setComposite(AlphaComposite.Src);
        }
        rm.copyArea(this,g,blitFromX,blitFromY,blitW,blitH,bdx,bdy,
                false);
        if(oldComposite!=null){
            ((Graphics2D)g).setComposite(oldComposite);
        }
        // Paint the newly exposed region.
        int x=view.getX();
        int y=view.getY();
        g.translate(x,y);
        g.setClip(clipX,clipY,clipW,clipH);
        view.paintForceDoubleBuffered(g);
        g.translate(-x,-y);
    }

    private void paintView(Graphics g){
        Rectangle clip=g.getClipBounds();
        JComponent view=(JComponent)getView();
        if(view.getWidth()>=getWidth()){
            // Graphics is relative to JViewport, need to map to view's
            // coordinates space.
            int x=view.getX();
            int y=view.getY();
            g.translate(x,y);
            g.setClip(clip.x-x,clip.y-y,clip.width,clip.height);
            view.paintForceDoubleBuffered(g);
            g.translate(-x,-y);
            g.setClip(clip.x,clip.y,clip.width,clip.height);
        }else{
            // To avoid any problems that may result from the viewport being
            // bigger than the view we start painting from the viewport.
            try{
                inBlitPaint=true;
                paintForceDoubleBuffered(g);
            }finally{
                inBlitPaint=false;
            }
        }
    }

    private boolean canUseWindowBlitter(){
        if(!isShowing()||(!(getParent() instanceof JComponent)&&
                !(getView() instanceof JComponent))){
            return false;
        }
        if(isPainting()){
            // We're in the process of painting, don't blit. If we were
            // to blit we would draw on top of what we're already drawing,
            // so bail.
            return false;
        }
        Rectangle dirtyRegion=RepaintManager.currentManager(this).
                getDirtyRegion((JComponent)getParent());
        if(dirtyRegion!=null&&dirtyRegion.width>0&&
                dirtyRegion.height>0){
            // Part of the scrollpane needs to be repainted too, don't blit.
            return false;
        }
        Rectangle clip=new Rectangle(0,0,getWidth(),getHeight());
        Rectangle oldClip=new Rectangle();
        Rectangle tmp2=null;
        Container parent;
        Component lastParent=null;
        int x, y, w, h;
        for(parent=this;parent!=null&&isLightweightComponent(parent);parent=parent.getParent()){
            x=parent.getX();
            y=parent.getY();
            w=parent.getWidth();
            h=parent.getHeight();
            oldClip.setBounds(clip);
            SwingUtilities.computeIntersection(0,0,w,h,clip);
            if(!clip.equals(oldClip))
                return false;
            if(lastParent!=null&&parent instanceof JComponent&&
                    !((JComponent)parent).isOptimizedDrawingEnabled()){
                Component comps[]=parent.getComponents();
                int index=0;
                for(int i=comps.length-1;i>=0;i--){
                    if(comps[i]==lastParent){
                        index=i-1;
                        break;
                    }
                }
                while(index>=0){
                    tmp2=comps[index].getBounds(tmp2);
                    if(tmp2.intersects(clip))
                        return false;
                    index--;
                }
            }
            clip.x+=x;
            clip.y+=y;
            lastParent=parent;
        }
        if(parent==null){
            // No Window parent.
            return false;
        }
        return true;
    }
/////////////////
// Accessibility support
////////////////

    protected class ViewListener extends ComponentAdapter implements Serializable{
        public void componentResized(ComponentEvent e){
            fireStateChanged();
            revalidate();
        }
    }

    protected class AccessibleJViewport extends AccessibleJComponent{
        public AccessibleRole getAccessibleRole(){
            return AccessibleRole.VIEWPORT;
        }
    } // inner class AccessibleJViewport
}
